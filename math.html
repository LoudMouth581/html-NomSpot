<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Math Star Battle</title>
<style>
  body {
    margin:0; padding:0;
    background: linear-gradient(135deg, #0b0c1a, #1a2140);
    color:#0ff;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    overflow-x: hidden;
  }
  #game {
    max-width: 800px;
    margin: 0 auto;
    padding: 10px 20px 40px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  #header {
    display: flex;
    justify-content: space-between;
    width: 100%;
    margin-bottom: 10px;
    font-size: 1.5rem;
    font-weight: 600;
  }
  #questionBillboard {
    font-size: 2rem;
    font-weight: 700;
    background: rgba(0,255,255,0.15);
    border-radius: 12px;
    padding: 12px 20px;
    margin-bottom: 20px;
    text-align: center;
    width: 100%;
    min-height: 3.5rem;
    user-select:none;
  }
  #answersContainer {
    position: relative;
    width: 100%;
    height: 280px;
    border: 2px solid #0ff;
    border-radius: 16px;
    overflow: hidden;
    background: radial-gradient(circle at center, #07111d 0%, #00081f 90%);
    margin-bottom: 30px;
  }
  .answerBubble {
    position: absolute;
    width: 70px;
    height: 70px;
    background: linear-gradient(135deg, #7ef9ff, #00fff7);
    clip-path: polygon(
      50% 0%, 61% 35%, 98% 35%, 68% 57%,
      79% 91%, 50% 70%, 21% 91%, 32% 57%,
      2% 35%, 39% 35%
    );
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: 700;
    font-size: 1.6rem;
    color: #00444d;
    text-shadow: 0 0 6px #00fff7;
    cursor: pointer;
    user-select:none;
    transition: transform 0.2s ease;
  }
  .answerBubble:hover {
    transform: scale(1.1);
    box-shadow: 0 0 12px #00fff7;
  }
  #ship {
    position: relative;
    width: 60px;
    height: 60px;
    margin-bottom: 20px;
  }
  #ship svg polygon {
    fill: #ffd700;
    filter: drop-shadow(0 0 6px #ffdd55);
  }
  #shipContainer {
    width: 100%;
    height: 80px;
    position: relative;
    margin-bottom: 30px;
    border-top: 2px solid #0ff;
    background: linear-gradient(90deg, #002a33, #001c26);
  }
  #ship {
    position: absolute;
    top: 10px;
    left: 10px;
    transition: left 0.3s ease;
  }
  #controls {
    display: flex;
    gap: 20px;
    align-items: center;
  }
  .btn {
    font-size: 1.5rem;
    background: #00fff7;
    border: none;
    border-radius: 12px;
    padding: 12px 20px;
    cursor: pointer;
    user-select:none;
    color: #00363b;
    font-weight: 700;
    box-shadow: 0 0 10px #00fff7;
    transition: background-color 0.3s ease;
  }
  .btn:hover {
    background: #00c8b9;
  }
  #speedControl {
    width: 180px;
    -webkit-appearance: none;
    background: transparent;
    cursor: pointer;
  }
  #speedControl:focus {
    outline: none;
  }
  /* Slider track */
  #speedControl::-webkit-slider-runnable-track {
    height: 12px;
    background: #00fff7;
    border-radius: 12px;
    box-shadow: 0 0 10px #00fff7;
  }
  #speedControl::-moz-range-track {
    height: 12px;
    background: #00fff7;
    border-radius: 12px;
    box-shadow: 0 0 10px #00fff7;
  }
  /* Slider thumb (star shape) */
  #speedControl::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 40px;
    height: 40px;
    background: #ffd700;
    clip-path: polygon(
      50% 0%, 61% 35%, 98% 35%, 68% 57%,
      79% 91%, 50% 70%, 21% 91%, 32% 57%,
      2% 35%, 39% 35%
    );
    box-shadow: 0 0 10px #ffdd55;
    margin-top: -14px;
    transition: background 0.3s ease;
  }
  #speedControl::-webkit-slider-thumb:hover {
    background: #ffdd00;
  }
  #speedControl::-moz-range-thumb {
    width: 40px;
    height: 40px;
    background: #ffd700;
    clip-path: polygon(
      50% 0%, 61% 35%, 98% 35%, 68% 57%,
      79% 91%, 50% 70%, 21% 91%, 32% 57%,
      2% 35%, 39% 35%
    );
    box-shadow: 0 0 10px #ffdd55;
    transition: background 0.3s ease;
    border: none;
  }

  #modeSelector {
    margin-top: 30px;
    display: flex;
    gap: 20px;
    font-weight: 600;
  }
  #modeSelector label {
    cursor: pointer;
  }

  /* Projectile star */
  .projectile {
    position: absolute;
    width: 40px;
    height: 40px;
    background: linear-gradient(135deg, #fffc33, #f7d64e);
    clip-path: polygon(
      50% 0%, 61% 35%, 98% 35%, 68% 57%,
      79% 91%, 50% 70%, 21% 91%, 32% 57%,
      2% 35%, 39% 35%
    );
    box-shadow: 0 0 15px #fff850;
    filter: drop-shadow(0 0 8px #fff850);
    pointer-events: none;
    user-select:none;
    z-index: 100;
  }

  /* AI Tutor */
  #aiTutor {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: rgba(0, 255, 255, 0.15);
    padding: 12px 18px 12px 60px;
    border-radius: 20px;
    color: #00ffff;
    font-weight: 600;
    max-width: 320px;
    user-select:none;
    box-shadow: 0 0 15px #0ff;
  }
  #aiTutor .starOrb {
    position: absolute;
    left: 12px;
    top: 12px;
    width: 36px;
    height: 36px;
    background: linear-gradient(135deg, #7ef9ff, #00fff7);
    clip-path: polygon(
      50% 0%, 61% 35%, 98% 35%, 68% 57%,
      79% 91%, 50% 70%, 21% 91%, 32% 57%,
      2% 35%, 39% 35%
    );
    box-shadow: 0 0 20px #00fff7;
    filter: drop-shadow(0 0 10px #00fff7);
  }

  /* Responsive */
  @media (max-width: 480px) {
    #answersContainer {
      height: 180px;
    }
    .answerBubble {
      width: 50px;
      height: 50px;
      font-size: 1.2rem;
    }
    #ship {
      width: 40px;
      height: 40px;
    }
    #speedControl {
      width: 130px;
    }
    #aiTutor {
      max-width: 220px;
      font-size: 0.9rem;
      padding-left: 50px;
    }
    #aiTutor .starOrb {
      width: 28px;
      height: 28px;
      top: 8px;
      left: 10px;
    }
  }
</style>
</head>
<body>
  <div id="game" role="main" aria-label="Math Star Battle game">
    <header id="header" aria-live="polite" aria-atomic="true">
      <div id="scoreboard" aria-label="Current score">Score: 0</div>
      <div id="timer" aria-label="Time remaining">Time: 60</div>
    </header>

    <section id="questionBillboard" aria-live="polite" aria-atomic="true">Loading...</section>

    <section id="answersContainer" aria-label="Answer options" role="list" tabindex="0"></section>

    <div id="shipContainer" aria-label="Ship movement area">
      <div id="ship" role="img" aria-label="Your star shooter" tabindex="0" >
        <svg viewBox="0 0 64 64" width="60" height="60" aria-hidden="true" focusable="false">
          <polygon points="32 2 39 22 62 24 43 37 49 60 32 48 15 60 21 37 2 24 25 22" />
        </svg>
      </div>
    </div>

    <div id="controls" aria-label="Game controls">
      <button class="btn" id="btnLeft" aria-label="Move left">&#8592;</button>
      <button class="btn" id="btnFire" aria-label="Fire projectile">&#9733;</button>
      <button class="btn" id="btnRight" aria-label="Move right">&#8594;</button>
      <input type="range" min="1" max="5" value="3" id="speedControl" aria-label="Projectile speed control" />
    </div>

    <form id="modeSelector" aria-label="Select game mode">
      <label><input type="radio" name="mode" value="addition" checked /> Addition Level</label>
      <label><input type="radio" name="mode" value="subtraction" /> Subtraction Level</label>
      <label><input type="radio" name="mode" value="opponent" /> Opponent Mode</label>
    </form>
  </div>

  <aside id="aiTutor" role="complementary" aria-live="polite" aria-atomic="true">
    <div class="starOrb" aria-hidden="true"></div>
    <div id="aiMessage">Get ready for a starry math battle!</div>
  </aside>

<script>
(() => {
  const scoreboard = document.getElementById('scoreboard');
  const timerEl = document.getElementById('timer');
  const questionBillboard = document.getElementById('questionBillboard');
  const answersContainer = document.getElementById('answersContainer');
  const ship = document.getElementById('ship');
  const btnLeft = document.getElementById('btnLeft');
  const btnRight = document.getElementById('btnRight');
  const btnFire = document.getElementById('btnFire');
  const speedControl = document.getElementById('speedControl');
  const aiMessage = document.getElementById('aiMessage');
  const modeRadios = document.querySelectorAll('input[name="mode"]');

  let currentMode = 'addition';
  let score = 0;
  let timeLeft = 60;
  let timerInterval = null;
  let wrongCount = 0;

  // Store answer elements and their float data
  let answers = [];
  let floatDirections = [];
  let floatPositions = [];

  let shipPosIndex = 0;
  let projectile = null;
  let speed = Number(speedControl.value);

  const maxAnswers = 5;

  // AI Tutor tips for encouragement/hints
  const tutorTips = {
    addition: [
      "Great job adding stars! Keep it up!",
      "Remember, adding means putting numbers together.",
      "Try to answer quickly for bonus points!",
      "Keep your eyes on the stars!"
    ],
    subtraction: [
      "Nice work subtracting stars!",
      "Think of taking stars away.",
      "You can do it, keep practicing!",
      "Subtracting gets easier with practice!"
    ],
    opponent: [
      "Math is fun! Show them your skills!",
      "Focus and aim carefully!",
      "Choose the right star quickly!",
      "You're a math star!"
    ]
  };

  function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // Generate question and answers based on mode and level of difficulty (scale with score)
  function generateQuestionAndAnswers() {
    let a, b, question, correctAns;
    const difficulty = Math.min(10, Math.floor(score / 20) + 2);

    if(currentMode === 'addition') {
      a = randomInt(1, difficulty * 10);
      b = randomInt(1, difficulty * 10);
      correctAns = a + b;
      question = `${a} + ${b} = ?`;
    } else if(currentMode === 'subtraction') {
      a = randomInt(difficulty * 5, difficulty * 10 + 10);
      b = randomInt(1, a);
      correctAns = a - b;
      question = `${a} - ${b} = ?`;
    } else { // opponent mode with mixed operators
      const ops = ['+', '-', '*', '/'];
      const op = ops[randomInt(0, ops.length -1)];

      if(op === '+') {
        a = randomInt(1, difficulty * 10);
        b = randomInt(1, difficulty * 10);
        correctAns = a + b;
        question = `${a} + ${b} = ?`;
      } else if(op === '-') {
        a = randomInt(difficulty * 5, difficulty * 10 + 10);
        b = randomInt(1, a);
        correctAns = a - b;
        question = `${a} - ${b} = ?`;
      } else if(op === '*') {
        a = randomInt(1, difficulty + 3);
        b = randomInt(1, difficulty + 3);
        correctAns = a * b;
        question = `${a} × ${b} = ?`;
      } else {
        // Division with integer results only
        b = randomInt(1, difficulty + 3);
        correctAns = randomInt(1, difficulty + 3);
        a = b * correctAns;
        question = `${a} ÷ ${b} = ?`;
      }
    }

    // Generate answers array with one correct and others as nearby randoms
    const answersArr = [correctAns];
    while(answersArr.length < maxAnswers) {
      let randAns = correctAns + randomInt(-difficulty * 3, difficulty * 3);
      if(randAns < 0) randAns = 0;
      if(!answersArr.includes(randAns)) answersArr.push(randAns);
    }

    // Shuffle answers
    for(let i = answersArr.length -1; i > 0; i--) {
      const j = randomInt(0, i);
      [answersArr[i], answersArr[j]] = [answersArr[j], answersArr[i]];
    }

    return { question, answers: answersArr, correctAns };
  }

  let currentAnswer = null;

  // Clear old answers and create new bubbles, position randomly inside container
  function setupAnswers() {
    answersContainer.innerHTML = '';
    answers = [];
    floatDirections = [];
    floatPositions = [];

    const { question, answers: ansArr, correctAns } = generateQuestionAndAnswers();

    currentAnswer = correctAns;
    questionBillboard.textContent = question;

    const containerRect = answersContainer.getBoundingClientRect();
    const containerWidth = answersContainer.clientWidth;
    const containerHeight = answersContainer.clientHeight;

    for(let i = 0; i < ansArr.length; i++) {
      const bubble = document.createElement('div');
      bubble.className = 'answerBubble';
      bubble.setAttribute('role', 'listitem');
      bubble.setAttribute('tabindex', '0');
      bubble.textContent = ansArr[i];
      bubble.dataset.value = ansArr[i];

      // Random position inside container with margin to avoid clipping
      const margin = 80;
      const x = randomInt(margin, containerWidth - margin);
      const y = randomInt(margin, containerHeight - margin);
      bubble.style.left = x + 'px';
      bubble.style.top = y + 'px';

      answersContainer.appendChild(bubble);

      // Save position and random float direction
      floatPositions.push({x, y});
      floatDirections.push({x: (Math.random() - 0.5) * 0.6, y: (Math.random() - 0.5) * 0.6});

      answers.push({el: bubble, val: ansArr[i]});

      // Clicking bubble selects it (optional shortcut)
      bubble.addEventListener('click', () => {
        const idx = answers.findIndex(a => a.el === bubble);
        shipPosIndex = idx;
        updateShipPosition();
        fireProjectile();
      });
    }

    shipPosIndex = 0;
    updateShipPosition();
  }

  // Animate floating stars gently bouncing inside container
  function animateStars() {
    const containerWidth = answersContainer.clientWidth;
    const containerHeight = answersContainer.clientHeight;

    answers.forEach((answer, i) => {
      let pos = floatPositions[i];
      let dir = floatDirections[i];

      pos.x += dir.x;
      pos.y += dir.y;

      // Bounce at edges (keep margin 70 for star size)
      if(pos.x < 20) {
        pos.x = 20;
        dir.x = -dir.x;
      }
      if(pos.x > containerWidth - 90) {
        pos.x = containerWidth - 90;
        dir.x = -dir.x;
      }
      if(pos.y < 20) {
        pos.y = 20;
        dir.y = -dir.y;
      }
      if(pos.y > containerHeight - 90) {
        pos.y = containerHeight - 90;
        dir.y = -dir.y;
      }

      floatPositions[i] = pos;
      floatDirections[i] = dir;

      answer.el.style.left = pos.x + 'px';
      answer.el.style.top = pos.y + 'px';
    });
  }

  // Move ship horizontally to answer bubbles index
  function updateShipPosition() {
    if(answers.length === 0) return;
    const containerWidth = answersContainer.clientWidth;

    // Ship moves to align under bubble horizontally; we calculate center positions of bubbles:
    const bubbleCenters = answers.map(a => {
      const rect = a.el.getBoundingClientRect();
      const parentRect = answersContainer.getBoundingClientRect();
      return rect.left + rect.width/2 - parentRect.left;
    });

    // Clamp shipPosIndex to valid range
    if(shipPosIndex < 0) shipPosIndex = 0;
    if(shipPosIndex >= bubbleCenters.length) shipPosIndex = bubbleCenters.length -1;

    const shipX = bubbleCenters[shipPosIndex] - ship.clientWidth / 2;

    ship.style.left = shipX + 'px';
  }

  // Move ship left/right by one bubble
  function moveShip(dir) {
    shipPosIndex += dir;
    if(shipPosIndex < 0) shipPosIndex = 0;
    if(shipPosIndex >= answers.length) shipPosIndex = answers.length -1;
    updateShipPosition();
  }

  // Fire projectile star toward current selected answer bubble
  function fireProjectile() {
    if(projectile) return; // only one at a time

    const projectileEl = document.createElement('div');
    projectileEl.className = 'projectile';
    projectileEl.setAttribute('aria-hidden', 'true');

    const shipRect = ship.getBoundingClientRect();
    const containerRect = answersContainer.getBoundingClientRect();

    const startX = shipRect.left + shipRect.width / 2 - containerRect.left - 20; // center offset
    const startY = answersContainer.clientHeight + 10;

    projectileEl.style.left = `${startX}px`;
    projectileEl.style.top = `${startY}px`;

    answersContainer.appendChild(projectileEl);
    projectile = { el: projectileEl, x: startX, y: startY };

    const targetBubble = answers[shipPosIndex].el;
    const targetRect = targetBubble.getBoundingClientRect();

    const targetX = targetRect.left + targetRect.width / 2 - containerRect.left - 20;
    const targetY = targetRect.top + targetRect.height / 2 - containerRect.top - 20;

    const dx = targetX - startX;
    const dy = targetY - startY;
    const distance = Math.sqrt(dx*dx + dy*dy);

    const speedPxPerFrame = speed * 2; // Adjust speed multiplier here

    let stepCount = distance / speedPxPerFrame;
    let stepX = dx / stepCount;
    let stepY = dy / stepCount;
    let step = 0;

    function animate() {
      if(!projectile) return;

      projectile.x += stepX;
      projectile.y += stepY;
      step++;

      projectile.el.style.left = projectile.x + 'px';
      projectile.el.style.top = projectile.y + 'px';

      // Simple collision: close enough or max steps
      let distToTarget = Math.sqrt((projectile.x - targetX) ** 2 + (projectile.y - targetY) ** 2);
      if(distToTarget < 10 || step >= stepCount) {
        checkAnswer(answers[shipPosIndex].val);

        // Remove projectile
        projectile.el.remove();
        projectile = null;
        return;
      }
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);
  }

  // Check if chosen answer is correct
  function checkAnswer(val) {
    if(Number(val) === currentAnswer) {
      score += Math.floor(10 + speed * 2 + (60 - timeLeft) * 0.5);
      aiSay("Correct! You're shining bright! ⭐");
      resetRound();
    } else {
      score = Math.max(0, score - 5);
      wrongCount++;
      aiSay("Oops! Try again, you've got this!");
      if(wrongCount >= 3) {
        aiSay("Hint: Remember to focus on the math problem!");
        wrongCount = 0;
      }
    }
    updateScoreboard();
  }

  // Update scoreboard and timer display
  function updateScoreboard() {
    scoreboard.textContent = `Score: ${score}`;
  }
  function updateTimer() {
    timerEl.textContent = `Time: ${timeLeft}`;
  }

  // Reset game round with new question and answers
  function resetRound() {
    setupAnswers();
  }

  // AI Tutor message with some randomness from current mode tips
  function aiSay(message) {
    if(message) {
      aiMessage.textContent = message;
      return;
    }
    const tips = tutorTips[currentMode];
    aiMessage.textContent = tips[randomInt(0, tips.length -1)];
  }

  // Timer countdown and game end
  function startTimer() {
    clearInterval(timerInterval);
    timeLeft = 60;
    updateTimer();

    timerInterval = setInterval(() => {
      timeLeft--;
      updateTimer();
      if(timeLeft <= 0) {
        clearInterval(timerInterval);
        aiSay(`Time's up! Your final score is ${score}. Refresh to play again!`);
        // Disable buttons
        btnFire.disabled = true;
        btnLeft.disabled = true;
        btnRight.disabled = true;
        speedControl.disabled = true;
      }
    }, 1000);
  }

  // Event listeners for controls
  btnLeft.addEventListener('click', () => moveShip(-1));
  btnRight.addEventListener('click', () => moveShip(1));
  btnFire.addEventListener('click', fireProjectile);
  speedControl.addEventListener('input', () => {
    speed = Number(speedControl.value);
  });

  modeRadios.forEach(radio => {
    radio.addEventListener('change', () => {
      currentMode = radio.value;
      score = 0;
      updateScoreboard();
      startTimer();
      resetRound();
      aiSay();
    });
  });

  // Initial setup
  function gameLoop() {
    animateStars();
    requestAnimationFrame(gameLoop);
  }

  updateScoreboard();
  startTimer();
  resetRound();
  aiSay();

  gameLoop();

})();
</script>
</body>
</html>
