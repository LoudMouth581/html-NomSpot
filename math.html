<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Accounting Math Blaster Bubble Pop</title>
<style>
  /* Base & reset */
  body, html {
    margin: 0; padding: 0; overflow: hidden;
    height: 100%; background: radial-gradient(circle at center, #001022, #000000);
    color: #0ff;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select: none;
  }
  #game {
    position: relative;
    width: 100vw;
    height: 100vh;
    max-width: 480px;
    margin: 0 auto;
    overflow: hidden;
    background: radial-gradient(circle at bottom, #002033, #000010);
    box-shadow: 0 0 15px #0ff inset;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  #header {
    width: 100%;
    padding: 12px;
    display: flex;
    justify-content: space-between;
    font-weight: 700;
    font-size: 1.3rem;
    user-select: none;
  }
  #question {
    font-size: 2rem;
    font-weight: 900;
    margin: 10px 0 4px;
    text-align: center;
    text-shadow: 0 0 10px #0ff;
    user-select: none;
  }
  #score, #timer {
    color: #0ff;
  }
  #playfield {
    position: relative;
    flex-grow: 1;
    width: 100%;
    background: #000011;
    overflow: hidden;
    border-radius: 14px;
    touch-action: none;
  }
  /* Shooter */
  #shooter {
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    width: 50px;
    height: 60px;
    background: linear-gradient(135deg, #0ff, #00bbcc);
    clip-path: polygon(50% 0%, 80% 100%, 20% 100%);
    box-shadow: 0 0 12px #0ff;
  }
  /* Laser */
  .laser {
    position: absolute;
    width: 4px;
    height: 20px;
    background: #0ff;
    border-radius: 2px;
    box-shadow: 0 0 10px #0ff;
  }
  /* Bubble style */
  .bubble {
    position: absolute;
    width: 70px;
    height: 70px;
    background: linear-gradient(135deg, #7ef9ff, #00fff7);
    clip-path: polygon(
      50% 0%, 61% 35%, 98% 35%, 68% 57%,
      79% 91%, 50% 70%, 21% 91%, 32% 57%,
      2% 35%, 39% 35%
    );
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 1.6rem;
    font-weight: 800;
    color: #00444d;
    text-shadow: 0 0 8px #00fff7;
    box-shadow: 0 0 12px #00fff7;
    user-select: none;
  }
  /* Pop animation */
  .pop {
    animation: popAnim 0.4s forwards;
  }
  @keyframes popAnim {
    to {
      transform: scale(2);
      opacity: 0;
    }
  }
  /* Feedback */
  #feedback {
    height: 28px;
    text-align: center;
    margin: 6px 0;
    font-weight: 700;
    font-size: 1.2rem;
    min-height: 28px;
    user-select: none;
  }
  /* Start button */
  #startBtn {
    margin: 6px 0 10px;
    padding: 12px 24px;
    border: none;
    border-radius: 14px;
    background: #0ff;
    color: #00444d;
    font-weight: 700;
    font-size: 1.3rem;
    cursor: pointer;
    user-select: none;
    transition: background 0.3s ease;
  }
  #startBtn:hover:not(:disabled) {
    background: #00ccc7;
  }
  #startBtn:disabled {
    background: #006666;
    cursor: not-allowed;
  }
  /* Responsive */
  @media (max-width: 400px) {
    .bubble {
      width: 55px;
      height: 55px;
      font-size: 1.2rem;
    }
    #shooter {
      width: 40px;
      height: 48px;
    }
  }
</style>
</head>
<body>
<div id="game">
  <div id="header">
    <div id="score">Score: 0</div>
    <div id="timer">Time: 60</div>
  </div>
  <div id="question">Press Start to Begin</div>
  <div id="playfield">
    <div id="shooter"></div>
  </div>
  <div id="feedback"></div>
  <button id="startBtn">Start Game</button>
</div>

<script>
(() => {
  const scoreEl = document.getElementById('score');
  const timerEl = document.getElementById('timer');
  const questionEl = document.getElementById('question');
  const playfield = document.getElementById('playfield');
  const feedbackEl = document.getElementById('feedback');
  const startBtn = document.getElementById('startBtn');
  const shooter = document.getElementById('shooter');

  const playfieldRect = () => playfield.getBoundingClientRect();

  let score = 0;
  let timeLeft = 60;
  let timerInterval = null;
  let gameActive = false;

  let currentAnswer = null;
  let bubbles = [];
  let lasers = [];

  const bubblesCount = 7;
  const laserSpeed = 12;

  // Utilities
  function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // Generate a question & answers for accounting addition practice
  function generateQA() {
    const maxNum = Math.min(15 + Math.floor(score / 3), 99);
    const a = randomInt(1, maxNum);
    const b = randomInt(1, maxNum);
    currentAnswer = a + b;
    const question = `${a} + ${b}`;
    const answersSet = new Set([currentAnswer]);

    while (answersSet.size < bubblesCount) {
      let candidate = currentAnswer + randomInt(-maxNum, maxNum);
      if (candidate < 0) candidate = 0;
      answersSet.add(candidate);
    }
    const answersArr = Array.from(answersSet);
    for (let i = answersArr.length - 1; i > 0; i--) {
      const j = randomInt(0, i);
      [answersArr[i], answersArr[j]] = [answersArr[j], answersArr[i]];
    }
    return { question, answers: answersArr };
  }

  // Create bubble element and initial position
  function createBubble(value) {
    const bubble = document.createElement('div');
    bubble.className = 'bubble';
    bubble.textContent = value;

    const pfWidth = playfield.clientWidth;
    const pfHeight = playfield.clientHeight;

    const x = randomInt(30, pfWidth - 100);
    const y = randomInt(-150, -70); // start above view

    bubble.style.left = `${x}px`;
    bubble.style.top = `${y}px`;

    playfield.appendChild(bubble);

    return {
      el: bubble,
      value,
      x,
      y,
      speedY: 1 + Math.random() * 1.5
    };
  }

  // Setup bubbles for a question
  function setupBubbles(answers) {
    // Clear old bubbles
    bubbles.forEach(b => {
      if (b.el.parentNode) b.el.parentNode.removeChild(b.el);
    });
    bubbles = [];

    answers.forEach(val => {
      bubbles.push(createBubble(val));
    });
  }

  // Update bubble positions (moving downward)
  function updateBubbles() {
    const pfHeight = playfield.clientHeight;

    bubbles.forEach(b => {
      b.y += b.speedY;
      if (b.y > pfHeight + 80) {
        // Respawn above
        b.y = randomInt(-150, -70);
        b.x = randomInt(30, playfield.clientWidth - 100);
        b.speedY = 1 + Math.random() * 1.5;
      }
      b.el.style.transform = `translate(${b.x}px, ${b.y}px)`;
    });
  }

  // Create laser and shoot from current shooter position
  function shootLaser() {
    if (!gameActive) return;

    const laser = document.createElement('div');
    laser.className = 'laser';

    const pfRect = playfield.getBoundingClientRect();
    const shooterRect = shooter.getBoundingClientRect();

    // Laser start position (center top of shooter relative to playfield)
    const startX = shooter.offsetLeft + shooter.clientWidth / 2 - 2; // 2px laser width offset
    const startY = shooter.offsetTop - 20; // just above shooter

    laser.style.left = `${startX}px`;
    laser.style.top = `${startY}px`;

    playfield.appendChild(laser);

    lasers.push({
      el: laser,
      x: startX,
      y: startY,
      speedY: -laserSpeed
    });
  }

  // Update laser positions and check collisions
  function updateLasers() {
    for (let i = lasers.length - 1; i >= 0; i--) {
      const laser = lasers[i];
      laser.y += laser.speedY;
      if (laser.y < -30) {
        // Remove laser out of screen
        laser.el.remove();
        lasers.splice(i, 1);
        continue;
      }
      laser.el.style.transform = `translate(${laser.x}px, ${laser.y}px)`;

      // Check collision with bubbles
      for (let j = bubbles.length - 1; j >= 0; j--) {
        const b = bubbles[j];
        if (isColliding(laser, b)) {
          // Hit detected
          if (b.value === currentAnswer) {
            score += 10;
            feedbackEl.textContent = "✅ Correct!";
            feedbackEl.style.color = "#0f0";
            popBubble(b, true);
            nextQuestion();
          } else {
            score = Math.max(0, score - 5);
            feedbackEl.textContent = "❌ Wrong!";
            feedbackEl.style.color = "#f33";
            popBubble(b, false);
          }
          updateScore();

          // Remove laser
          laser.el.remove();
          lasers.splice(i, 1);
          break;
        }
      }
    }
  }

  // Check collision between laser and bubble (approximate)
  function isColliding(laser, bubble) {
    const lRect = laser.el.getBoundingClientRect();
    const bRect = bubble.el.getBoundingClientRect();
    return !(
      lRect.right < bRect.left ||
      lRect.left > bRect.right ||
      lRect.bottom < bRect.top ||
      lRect.top > bRect.bottom
    );
  }

  // Pop bubble animation and removal
  function popBubble(bubbleObj, correct) {
    const el = bubbleObj.el;
    el.classList.add('pop');
    if (correct) {
      el.style.background = '#0f0';
      el.style.boxShadow = '0 0 20px #0f0';
    } else {
      el.style.background = '#f33';
      el.style.boxShadow = '0 0 20px #f33';
    }
    setTimeout(() => {
      if (el.parentNode) el.parentNode.removeChild(el);
    }, 400);
    // Remove bubble from array
    bubbles = bubbles.filter(b => b !== bubbleObj);
  }

  // Next question setup
  function nextQuestion() {
    const qa = generateQA();
    currentAnswer = qa.answers.find(a => a === currentAnswer) || qa.answers[0];
    questionEl.textContent = qa.question;
    setupBubbles(qa.answers);
  }

  // Update score display
  function updateScore() {
    scoreEl.textContent = `Score: ${score}`;
  }

  // Timer countdown
  function startTimer() {
    timeLeft = 60;
    timerEl.textContent = `Time: ${timeLeft}`;
    timerInterval = setInterval(() => {
      timeLeft--;
      timerEl.textContent = `Time: ${timeLeft}`;
      if (timeLeft <= 0) {
        endGame();
      }
    }, 1000);
  }

  // End game state
  function endGame() {
    gameActive = false;
    clearInterval(timerInterval);
    questionEl.textContent = 'Game Over!';
    feedbackEl.textContent = `Your final score: ${score}`;

    bubbles.forEach(b => {
      if (b.el.parentNode) b.el.parentNode.removeChild(b.el);
    });
    bubbles = [];

    lasers.forEach(l => {
      if (l.el.parentNode) l.el.parentNode.removeChild(l.el);
    });
    lasers = [];

    startBtn.disabled = false;
    startBtn.textContent = 'Restart Game';
  }

  // Start game
  function startGame() {
    score = 0;
    updateScore();
    feedbackEl.textContent = '';
    startBtn.disabled = true;
    startBtn.textContent = 'Game in Progress...';
    gameActive = true;

    nextQuestion();
    startTimer();
  }

  // Game loop animation frame
  function gameLoop() {
    if (gameActive) {
      updateBubbles();
      updateLasers();
    }
    requestAnimationFrame(gameLoop);
  }

  // Move shooter horizontally with mouse or touch
  function moveShooter(x) {
    const pfWidth = playfield.clientWidth;
    let newX = x - playfield.getBoundingClientRect().left - shooter.clientWidth / 2;
    if (newX < 0) newX = 0;
    if (newX > pfWidth - shooter.clientWidth) newX = pfWidth - shooter.clientWidth;
    shooter.style.left = `${newX}px`;
  }

  // Event Listeners

  // Mouse move on playfield to move shooter
  playfield.addEventListener('mousemove', e => {
    if (!gameActive) return;
    moveShooter(e.clientX);
  });

  // Touch move on playfield to move shooter
  playfield.addEventListener('touchmove', e => {
    if (!gameActive) return;
    moveShooter(e.touches[0].clientX);
  }, { passive: false });

  // Shoot laser on click or tap inside playfield
  playfield.addEventListener('click', e => {
    if (!gameActive) return;
    shootLaser();
  });

  playfield.addEventListener('touchstart', e => {
    if (!gameActive) return;
    shootLaser();
  }, { passive: false });

  startBtn.addEventListener('click', startGame);

  // Start animation loop
  gameLoop();

  // Center shooter initially
  function centerShooter() {
    shooter.style.left = `${(playfield.clientWidth - shooter.clientWidth) / 2}px`;
  }
  window.addEventListener('resize', centerShooter);
  centerShooter();
})();
</script>
</body>
</html>
